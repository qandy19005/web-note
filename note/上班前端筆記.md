# 開發

- 流程
// 數字代表順序
- Api 4
|
- Component 2
|
- Foramt 6
|
- Model 5
|
- Store 3
|
- View 1

0. View import component
1. Component(呼叫api > Store)
2. Input(輸入) -> Validate(驗證資料)
3. Store(資料取得) -> 呼叫API -> Model 檢查資料 -> 輸出資料
4. Api(只做取得資料或發送資料) -> call api return data
5. Model(定義Key那些必須，欄位檢查) -> Check(驗證欄位，格式檢查) -> Default set(若後端未給key則帶入Default防止前端畫面渲染錯誤) -> 輸出設定好資料
6. Component(元件取得Store資料)
7. Format(整理 Store 資料根據view)
8. 顯示於 component 或 view
9. Error 處理: Global處理例外error, Format 邏輯層定義後端 error code, 最後於view層做額外處理
# 環境建置

vite + vue + prettier
參考網址: https://www.cnblogs.com/lin557/p/16799007.html


# Npm

- npm link
https://segmentfault.com/a/1190000040075935

- npm install
npm install packagename --save || -S >> dependencies 
npm install packagename --save-dev || -D >> devDependencies 開發環境
npm install packagename --save-optional || -O >> optionalDependencies

- npm version
X.Y.Z
X: Major, will breaking change
Y: Minor, can use new feature
Z: Patch, fix/patch
"x.y.z" stick
"^x.y.z" will not update when x change
"~x.y.z" will update to lastest version

# Prettier

npm install --dev-dependency prettier
[file] packeage.json
"scripts": {
    ...
    "format": "prettier --write \"**/*.+(js|json)\""
},

# Javascript

## CommonJs規範
[refer1] https://medium.com/@jedy05097952/%E6%A8%A1%E7%B5%84%E5%8C%96-2-commonjs-26d2b2071d80
[refer2] https://dwatow.github.io/2018/02-13-js-module-require-exports/
[def] 同步 | 一個檔案視為一個模組，讓模組回傳該回傳的東西
[example]
- Commonjs.js
const a = 1
module.exports = a // module.exports as return

- test.js
const test = require('./Commonjs.js') // require as call function
console.log(test) // 1

## 宣告 Url with params
const url = new URL(`${domain}${path}`);
const searchParams = new URLSearchParams(params);
url.search = searchParams;
[return] url.href; // https://domain/path?params
[refer] https://pjchender.blogspot.com/2018/08/js-javascript-url-parameters.html

## CLASS
- extend
[des] extend只適合用在 父 跟 子 是相同的 ex: Animal(父) > Dog(子)
## DOM

- Add class
[methods]
document.getElementById("myDIV").classList.add("mystyle", "anotherClass", "thirdClass");

-Remove class
[methods]
document.getElementById("myDIV").classList.remove("mystyle");

## 函式

- 宣告式 (Function Declarations)
[methods] 
function myFunc(a, b) {
    return a + b;
}
[note]
*有Hoisting
*有this, arguments(帶入的參數值)

- 匿名表達式 (Function Expressions w/o Function Name)
[methods]
const myFunc = function (a, b) {
    return a + b;
};
[note]
*變數名稱 != 函數名稱
*不具 Hoisting 效果
*有arguments

- 箭頭函示
[methods]
const sayHello = () => `Hello!`;
[note]
*不具 Hoisting 效果
*沒有 arguments
*this 的運作方式與傳統函數不同 **在vue中為windows所以vue中不會宣告箭頭函式

## 陣列
- 複製陣列
[methods] [...]
const newList = [...list]

- 判斷是否為陣列
[methods] constructor === Array
// 判斷物件陣列是否存在 在判斷是否為陣列
[use] variable.value && variable.value.constructor === Array
[refer] https://ithelp.ithome.com.tw/articles/10219475

- 物件屬性排序
[methods]
Array.sort(function (a, b) {
  return a.id - b.id;
});

- 取得物件屬性唯一值
[methods]
const set = new Set();
const removeDupArray = Array.filter(item => {
return !set.has(item.id) ? set.add(item.id) : false});
參考資料:
https://guahsu.io/2018/04/JavaScript-Duplicates-Array-Object/

- function陣列undefind處理
[methods] if (Array.isArray(arr)) { arr.push() };
[refer] https://bobbyhadz.com/blog/javascript-typeerror-object-push-is-not-a-function

- 判斷是否在陣列內
[methods] array.includes(<param>)
[return] Boolean

- 取得陣列第一筆
[methods] first = [...arr].shift(); 
[refer] https://www.techiedelight.com/get-first-element-array-javascript/

- 陣列中加入符號轉字串
[methods] array.join(',')
[return] "array1,array2,array3";

- 移除重複陣列
[methods] array.filter((element, index)=> { return array.indexOf(element) === index; })
[methods] Lodash _.uniq(array)

- 移除重複陣列物件
[methods]
    const set = new Set();
    const filteredArray = array.filter((item) => {
      return !set.has(item.uuid) ? set.add(item.uuid) : false;
    })

- 合併相同id物件的陣列
[example]
combineArray = firstDatas.map(list => {
    const item = secondDatas.find(item => {
        return list.id === item.id
    })
    return { ...list, ...item }
})

## 物件
- Object.assign({}, text) 
[des] 合併(merges)或混合(Mixins)、拷貝
[example]
copy:
const obj = { a: 1 }
const copy = Object.assign({}, obj)

combine:
const o1 = { a: 1, b: 1, c: 1 }
const o2 = { b: 2, c: 2 }
const o3 = { c: 3 }
const obj = Object.assign({}, o1, o2, o3)
console.log(obj) // { a: 1, b: 2, c: 3 } . 傳入放愈後面位置的物件，它的屬性會覆蓋掉前面的物件

- let newAry = JSON.parse(JSON.stringify(ary))
[des] 物件陣列深層複製，更改物件深層值不互相影響

- lodash.clonedeep 複製多層物件

- 使用變數作為key名稱
[methods] {[<variable name>]: value}
[example] 
const name = "username"
let user = {
  [name]: "Andy"
}
user.username === "Andy"

- (?.)在進入key之前，檢查物件<object>是否為null或undefind
[methods] <object>?.key
[example] user?.name = user && user.name >> 先判斷user是否存在在判斷user.name
[advanced]
- (??)
[example] A ? A : B = A ?? B
若profile為null或undefind則帶入defaultProfile
const defaultProfile = { age: 0, contry: 'America' } ;
user?.profile??defaultProfile;

- 若物件為null照正常判斷
[methods] (<object> || {}).key

- 判斷物件是否為空
[methods] Object.keys(<object>).length === 0
[return] Boolean

- 物件跑forEach
[methods] 1. Object.keys(<object>).forEach > 顯示object key
[methods] 2. Object.values(<object>).forEach > 顯示object value
[methods] 3. Object.entries(<object>).forEach > 顯示object key:value

## File

- 判斷File格式 
[methods] <file> instanceof File
[return] Boolean

## lodash

處理陣列比對
1. intersectionBy
2. keyby+filter

陣列重新處理
- map

陣列篩選
- filter

## 時間處理
[格式]
const localDate = new Date(dateFromAPI);
const localDateString = localDate.toLocaleDateString(undefined, {  
    day:   'numeric',
    month: 'short',
    year:  'numeric',
});

const localTimeString = localDate.toLocaleTimeString(undefined, {
    hour:   '2-digit',
    minute: '2-digit',
    second: '2-digit',
});

## 其他
- 斷言
[methods] 辨識後加上 !
[example]
const partItem: Partial<SpecificPartType> = reactive({})

<FormPart
  v-for="item in partList"
  :key="item.bundle_part_type"
  :part-type="partItem[item.bundle_part_type]!"
  @remove-part-type="removePart"
/>

[description]
partItem 可能為 undefined
因此在 :part-type="partItem[item.bundle_part_type]!" 這行最後加上 !

# Vue
- shallowRef
[尚未查資料]

- 3.0 全域使用
[宣告]
const install = app => {
  app.config.globalProperties.<Params> = <Params>
}
export { install as default }

app.use(<import>);
[呼叫]
import { getCurrentInstance } from 'vue';
const { proxy } = getCurrentInstance();
proxy.{<Params>}

- 重新渲染HTML
[methods] <html :key="number"> </html>
[description] ++key can rerender html

- 父子層HTML
[問題1] 子層資料判斷綁定父層元件
[說明] 若子層引用父層元件，父層需要insertBefore需要先render再被子層處理才不會有問題
[錯誤範例] router-link 不能使用 (子層)v-if 會直接影響 DOMException Failed to execute 'insertBefore' on 'Node'

- CSS scoped 子層
[methods] :deep(.class-name) | ::v-deep

# React

# CSS

- 隱藏scroll
[methods] overflow: hidden;

- ul li 自動換行
[methods] word-break: break-all

# SCSS

- 宣告Function
[methods] @mixin <funciton> { css code }
[use] @include <funciton>

# HTML


## 問題

- 一個function做一件事情